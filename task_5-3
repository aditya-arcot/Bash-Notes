# recursive ls with hierarchy structure
# default depth - 4

# non-integer depth input results in ls without depth arg

# use only local vars

recls ()
{
	local line="|"
	local singletab="\t"
	local OPTIND OPTARG option depth hidden="false"

	while getopts ":d:h" option; do
		case $option in
			d )
				if [ $OPTARG  -lt 1 ]; then
					echo depth must be greater than 0
					return 1
				fi
				depth=$OPTARG;;
			h )
				hidden="true";;
			\? ) echo usage: recls [-d depth] [-h]
					return 1
		esac
	done
	shift $((OPTIND-1))

	if [ -z $depth ]; then
		depth=4
	fi

	local i maxtab
	for ((i=0; i<$depth; i++)); do
		maxtab+="$line$singletab"
	done

	if [ -z "$@" ]; then
		__recls_helper .
	else
		__recls_helper $@
	fi

	unset tab file subfile
}


__recls_helper ()
{
	for file
	do
		if [ ! -e "$file" ]
		then
			echo $file does not exist
		elif [ -d "$file" ]
		then
			echo $file
			if [ $hidden = true ]; then
				__recdir $(ls --color=always -a $file)
			else
				__recdir $(ls --color=always $file)
			fi
		else
			echo $file
		fi
		echo
	done

}

__recdir ()
{
	tab=$tab$line$singletab

	if [ "$tab" = "$maxtab" ]; then
		tab=${tab%"$line$singletab"}
		echo -e -n $tab$line
		echo -e "\t"...
		return 0
	fi

	for colored_subfile
	do
		subfile=$(echo $colored_subfile | decolorize)
		
		if [ "$subfile" != .. ] && [ "$subfile" != . ]
		then
			echo -e -n $tab
			echo -n $colored_subfile

			file=$file/$subfile

			if [ -d "$file" ]
			then
				echo /
				if [ $hidden = true ]; then
					__recdir $(ls --color=always -a $file)
				else
					__recdir $(ls --color=always $file)
				fi
			else
				#echo -e "$file"
				echo
			fi

			file=${file%/*}
		fi
	done

	tab=${tab%"$line$singletab"}
}

